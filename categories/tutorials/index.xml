<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tutorials on JavaIsland</title>
    <link>https://www.javai.net/categories/tutorials/</link>
    <description>Recent content in tutorials on JavaIsland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 13 Jun 2022 19:20:24 +0800</lastBuildDate><atom:link href="https://www.javai.net/categories/tutorials/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java Virtual Threads</title>
      <link>https://www.javai.net/post/202206/java-virtual-thread/</link>
      <pubDate>Mon, 13 Jun 2022 19:20:24 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202206/java-virtual-thread/</guid>
      <description>Virtual threading is something I&amp;rsquo;m really excited about. It&amp;rsquo;s a long-awaited feature in the language and we&amp;rsquo;ve made very few attempts to implement it in the past, but it&amp;rsquo;s finally here and it&amp;rsquo;s been merged into Java 19. This means that it will be included as a preview feature and we will be able to use it as soon as JDK 19 is released.
As I read this article I had to browse through many posts and videos.</description>
    </item>
    
    <item>
      <title>How to avoid memory leaks in java programs</title>
      <link>https://www.javai.net/post/202206/java-out-of-memory/</link>
      <pubDate>Sat, 11 Jun 2022 15:45:08 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202206/java-out-of-memory/</guid>
      <description>Although jvm has a garbage collection mechanism, if the program is written without paying attention to some specific rules, it can still lead to memory leaks in java programs, which may end up with OutOfMemory exceptions.
1. Causes of memory leaks in Java Objects in java are divided into 2 types in terms of usage, referenced and unreferenced. Garbage collection only recovers objects that are not referenced. Referenced objects, even if they are no longer used, are not recycled.</description>
    </item>
    
    <item>
      <title>ElasticSearch new version of JavaClient using the introduction</title>
      <link>https://www.javai.net/post/202206/elasticsearch-javaclient/</link>
      <pubDate>Sat, 11 Jun 2022 13:24:03 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202206/elasticsearch-javaclient/</guid>
      <description>The java client used by ElasticSearch before version 7.17 was the Java REST Client, but since version 7.17, the Java REST Client has been officially marked as deprecated and the new version of the Java Client is recommended. This article introduces the new version of the ElasticSearch Java Client&amp;rsquo;s basic usage. The specific code reference Example project.
I. Overview Elasticsearch 7.17 version of the new Java API Client has the following advantages.</description>
    </item>
    
    <item>
      <title>Java virtual thread (LOOM) and thread fairness</title>
      <link>https://www.javai.net/post/202205/java-virtual-thread-fair/</link>
      <pubDate>Tue, 31 May 2022 23:43:35 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202205/java-virtual-thread-fair/</guid>
      <description>Project Loom ( JEP 425 ) is probably one of the most anticipated additions to Java ever. Its implementation of virtual threading (or &amp;ldquo;green threading&amp;rdquo;) ensures that developers can create highly concurrent applications, such as those with hundreds of thousands of open HTTP connections, adhering to the well-known thread-per-request programming model without resorting to less familiar and often more complex reactive methods.
Only recently, after several years of effort, has Loom been merged into the main line of the OpenJDK and made available as a preview feature in the latest Java 19 early access release.</description>
    </item>
    
    <item>
      <title>Use of CyclicBarrier in java concurrency</title>
      <link>https://www.javai.net/post/202205/java-cyclicbarrier-use/</link>
      <pubDate>Thu, 12 May 2022 13:48:54 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202205/java-cyclicbarrier-use/</guid>
      <description>Introduction CyclicBarrier is a thread-safe component introduced in java 5. It has the concept of a barrier, which is used to wait for all threads to finish executing before performing a specific operation.
If we have many threads and each thread computes some data, then we need to wait for all the threads to finish executing and then add up the data computed by each thread to the final result, then we can use CyclicBarrier.</description>
    </item>
    
    <item>
      <title>Use of CountDownLatch in java concurrency</title>
      <link>https://www.javai.net/post/202205/java-countdownlatch-use/</link>
      <pubDate>Thu, 12 May 2022 13:34:16 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202205/java-countdownlatch-use/</guid>
      <description>Introduction In java concurrency, it is very important to control access to shared variables, sometimes we also want to control the order of execution of concurrent threads, for example: wait for all threads to finish executing before executing another thread, or wait for all threads to be ready before starting the execution of all threads, This time we can use CountDownLatch.
CountDownLatch contains a counter that is placed in the QueuedSynchronizer.</description>
    </item>
    
    <item>
      <title>Java stream common operations on streams</title>
      <link>https://www.javai.net/post/202205/java-stream-use/</link>
      <pubDate>Sat, 07 May 2022 17:04:19 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202205/java-stream-use/</guid>
      <description>Introduction As we all know, starting from Java8, jdk has added a new Stream class to complement the collection class.
Stream provides a higher-order abstraction of Java collection operations and expressions using an intuitive way similar to querying data from a database with SQL statements.
This style treats the collection of elements to be processed as a stream, which travels through the pipeline and can be processed at the nodes of the pipeline, such as filtering, sorting, aggregating, etc.</description>
    </item>
    
    <item>
      <title>High-performance collections EnumMap and EnumSet</title>
      <link>https://www.javai.net/post/202204/java-enum-collection/</link>
      <pubDate>Tue, 26 Apr 2022 15:25:32 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-enum-collection/</guid>
      <description>This article introduces EnumMap and EnumSet, which is a collection class under the java.util package.
The Map and Set structures are especially used in our daily work, and often used to store data or pass parameters, but there is no way to control the data setting of Map, we have no idea what kind of data others will put into it, or if the type and number of data Key of our Map is fixed in some scenarios, then in this case How can we improve the security and performance of the system?</description>
    </item>
    
    <item>
      <title>Basic use of ThreadPool</title>
      <link>https://www.javai.net/post/202204/java-thread-pool/</link>
      <pubDate>Wed, 20 Apr 2022 14:42:24 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-thread-pool/</guid>
      <description>Preface In Java, threads are the counterpart of system threads and are used to handle a range of system resources. The number of threads that can be opened is limited in both windows and linux, so if you create unlimited threads in your java program, you will encounter a situation where no threads can be created.
CPU cores are limited and if there are multiple threads running at the same time, the CPU will rotate according to the priority of the threads and allocate a specific amount of CPU time to each thread.</description>
    </item>
    
    <item>
      <title>The fork join framework in java</title>
      <link>https://www.javai.net/post/202204/java-fork-join/</link>
      <pubDate>Wed, 20 Apr 2022 14:33:27 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-fork-join/</guid>
      <description>Preface Fork join framework is the introduction of java 7 framework, the introduction of this framework is mainly to improve the ability of parallel computing.
Fork join has two main steps, the first is fork, a large task into many small tasks, the second is join, the results of the first task join up to generate the final result. If there is no return value in the first step, join will wait until all the small tasks are finished.</description>
    </item>
    
    <item>
      <title>Daemon Thread in Java</title>
      <link>https://www.javai.net/post/202204/java-daemon-thread/</link>
      <pubDate>Wed, 20 Apr 2022 14:19:16 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-daemon-thread/</guid>
      <description>Preface There are two types of threads in java, user threads and daemon threads.
User threads are high priority threads and the JVM will wait for all the User Threads to finish running before it finishes running.
daemon threads are low-priority threads that serve User Threads. Because daemon threads are low priority and serve only user threads, the JVM will automatically exit when all user threads are finished, regardless of whether there are still daemon threads running.</description>
    </item>
    
    <item>
      <title>Notes on upgrading from Java 8 to Java 11</title>
      <link>https://www.javai.net/post/202204/java-jdk8-upgrade-jdk11/</link>
      <pubDate>Tue, 19 Apr 2022 20:21:04 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-jdk8-upgrade-jdk11/</guid>
      <description>Preface Although the latest version of Java has evolved to Java 18, most projects on the market are still using Java 8. Many people are apprehensive about upgrading their Java version because the Java API is not necessarily forward compatible from Java 8. Java 11 is the next long-supported version of Java 8, and there is no doubt that Java 11 is even better than Java 8. superior.
This article describes the code checking tools used to convert code from Java 8 to Java 11, as well as the problems you may encounter and suggestions for resolving them.</description>
    </item>
    
    <item>
      <title>AbstractQueuedSynchronizer implementation principle - 2</title>
      <link>https://www.javai.net/post/202204/java-aqs-principle-2/</link>
      <pubDate>Tue, 19 Apr 2022 15:11:02 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-aqs-principle-2/</guid>
      <description>Preface In the previous articleAbstractQueuedSynchronizer implementation principle - 1, we explained the acquisition and release of exclusive synchronization state in AbstractQueuedSynchronizer, and here we start to explain the acquisition and release of shared synchronization state in AbstractQueuedSynchronizer.
Shared Synchronous State Acquisition and Release Shared lock as the name implies is that multiple threads can share a lock, use acquireShared in the synchronizer to get the shared lock (synchronous state), the source code of the method is as follows.</description>
    </item>
    
    <item>
      <title>AbstractQueuedSynchronizer implementation principle - 1</title>
      <link>https://www.javai.net/post/202204/java-aqs-principle-1/</link>
      <pubDate>Tue, 19 Apr 2022 14:29:23 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-aqs-principle-1/</guid>
      <description>Preface AbstractQueuedSynchronizer is the basic framework for implementing concurrency tools in the JDK, and a deeper understanding of it will help us to better use its features and related tools. We hope you will read this article carefully and gain something from it.
In Java, access to shared resources by multiple threads is controlled by lock. We know that the lock function can be implemented by the synchronized keyword, which can implicitly acquire locks, that is, we do not need to care about the process of acquiring and releasing locks by using this keyword, but while it provides convenience, it also means that its flexibility is reduced.</description>
    </item>
    
    <item>
      <title>Simple use of the Atomic class</title>
      <link>https://www.javai.net/post/202204/java-atomic-class/</link>
      <pubDate>Mon, 18 Apr 2022 17:14:34 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-atomic-class/</guid>
      <description>Problem Background In a multi-threaded environment, the most common problem we encounter is synchronizing the values of variables. Since variables need to be shared across multiple threads, we must need to employ some synchronization mechanism to control them.
From the previous article we know that the Lock mechanism can be used, and of course, the Atomic class we are talking about today.
Here we will introduce each of the two ways.</description>
    </item>
    
    <item>
      <title>Use of join in java</title>
      <link>https://www.javai.net/post/202204/java-join-use/</link>
      <pubDate>Mon, 18 Apr 2022 16:24:46 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-join-use/</guid>
      <description>Introduction join() is a method we often use in java that sets the current thread to the WAITTING state and then waits for the calling thread to finish executing or be interrupted.
Definition join() is a method defined in Thread, let&amp;rsquo;s look at his definition.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** * Waits for this thread to die.</description>
    </item>
    
    <item>
      <title>The life cycle of threads in java</title>
      <link>https://www.javai.net/post/202204/java-thread-life-cycle/</link>
      <pubDate>Mon, 18 Apr 2022 15:55:37 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-thread-life-cycle/</guid>
      <description>Introduction Threads is a frequently used technology in java, this article will explain in detail the life cycle of threads in java, I hope you can give some help.
The state of Thread in java There are six states of Thread in java, which are.
 NEW - newly created Thread, has not yet started execution RUNNABLE - Thread in runnable state, including ready to run and running. BLOCKED - Threads that are waiting for a resource lock WAITING - A thread that is waiting indefinitely for other threads to perform a specific operation TIMED_WAITING - Waiting for a certain amount of time for other threads to perform a specific operation TERMINATED - the thread has finished executing  We can visualize this in a diagram.</description>
    </item>
    
    <item>
      <title>The use of ThreadLocal in java</title>
      <link>https://www.javai.net/post/202204/java-threadlocal-use/</link>
      <pubDate>Sun, 17 Apr 2022 13:47:38 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-threadlocal-use/</guid>
      <description>Preface ThreadLocal is mainly used to store data for the current thread, this data is only accessible by the current thread.
When defining a ThreadLocal, we can also define specific types of objects stored in the ThreadLocal.
1  ThreadLocal&amp;lt;Integer&amp;gt; threadLocalValue = new ThreadLocal&amp;lt;&amp;gt;();   Above we have defined a ThreadLocal object that stores an Integer.
To store and get the object in ThreadLocal is also very simple, using get() and set().</description>
    </item>
    
    <item>
      <title>The difference between Runnable and Callable in java</title>
      <link>https://www.javai.net/post/202204/java-runnable-callable/</link>
      <pubDate>Sun, 17 Apr 2022 13:40:15 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-runnable-callable/</guid>
      <description>Preface In java&amp;rsquo;s multi-threaded development Runnable has always been the core of multi-threading, and Callable is an enhanced version of java 1.5 added in.
In this article, we will explore the differences between Runnable and Callable in detail.
Operation mechanism First look at the interface definition of Runnable and Callable:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @FunctionalInterface public interface Runnable { /** * When an object implementing interface &amp;lt;code&amp;gt;Runnable&amp;lt;/code&amp;gt; is used * to create a thread, starting the thread causes the object&amp;#39;s * &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; method to be called in that separately executing * thread.</description>
    </item>
    
    <item>
      <title>The use of ExecutorService in java concurrency</title>
      <link>https://www.javai.net/post/202204/java-executorservice-use/</link>
      <pubDate>Sun, 17 Apr 2022 13:29:57 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-executorservice-use/</guid>
      <description>Preface ExecutorService is a framework for asynchronous execution in java. By using ExecutorService you can easily create a multi-threaded execution environment.
This article will explain in detail the specific use of ExecutorService.
Creating an ExecutorService Generally speaking, there are two ways to create an ExecutorService.
The first way is to use the factory class methods in Executors, for example.
1  ExecutorService executor = Executors.newFixedThreadPool(10);   In addition to the newFixedThreadPool method, Executors contains a number of methods to create an ExecutorService.</description>
    </item>
    
  </channel>
</rss>

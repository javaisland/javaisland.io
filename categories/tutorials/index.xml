<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tutorials on JavaIsland</title>
    <link>https://www.javai.net/categories/tutorials/</link>
    <description>Recent content in tutorials on JavaIsland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 07 Apr 2022 16:01:20 +0800</lastBuildDate><atom:link href="https://www.javai.net/categories/tutorials/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Application of Volatile</title>
      <link>https://www.javai.net/post/202204/volatile-application/</link>
      <pubDate>Thu, 07 Apr 2022 16:01:20 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/volatile-application/</guid>
      <description>Memory Visibility Since the Java Memory Model (JMM) states that all variables are stored in main memory, and each thread has its own working memory (cache).
When a thread is working, it needs to copy the data from the main memory to the working memory. This way, any operation on the data is based on the working memory (which is more efficient) and cannot directly manipulate the data in the main memory or the working memory of other threads, and then flush the updated data to the main memory afterwards.</description>
    </item>
    
    <item>
      <title>ReentrantLock implementation principle</title>
      <link>https://www.javai.net/post/202204/reentrantlock-principle/</link>
      <pubDate>Wed, 06 Apr 2022 16:30:46 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/reentrantlock-principle/</guid>
      <description>When using synchronize to do synchronization, lock acquisition and release are implicitly implemented by compiling and adding different machine instructions to achieve the principle.
 ReentrantLock is a class based on AbstractQueuedSynchronizer(AQS for short) implementation, this article analyzes the implementation principle of ReentrantLock, I hope it will be helpful to you.
ReentrantLock: a thread can still repeat the lock after it has obtained it, and will not appear to block itself.</description>
    </item>
    
    <item>
      <title>Practical Applications of Reflection - Building Log Objects</title>
      <link>https://www.javai.net/post/202204/java-reflect-application/</link>
      <pubDate>Wed, 06 Apr 2022 16:16:21 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-reflect-application/</guid>
      <description>Preface In our practical development, we often use reflection, I present an example of the logging function done by reflection in practical development.
Traditional logging Some basic knowledge about reflection can be found in Reflection Primer.
I believe that logging is not new to you, in the actual development of some more sensitive data tables we need to record every operation of it.
First, let&amp;rsquo;s look at the traditional way of writing.</description>
    </item>
    
    <item>
      <title>How to implement detection of undirected and directed loops in Java</title>
      <link>https://www.javai.net/post/202204/detect-loops/</link>
      <pubDate>Wed, 06 Apr 2022 13:59:55 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/detect-loops/</guid>
      <description>Undirected rings An undirected graph with rings is shown below, where there are two rings, 0-2-1-0 and 2-3-4-2, respectively.
To detect rings in an undirected graph, you can use depth-first search. Suppose we start from vertex 0, then walk to the adjacent vertex 2, then walk to the vertex 1 adjacent to vertex 2. Since vertex 0 and vertex 1 are adjacent and vertex 0 is labeled, it means we have spared a loop, so there is a loop in the undirected graph.</description>
    </item>
    
    <item>
      <title>How to implement undirected graphs in Java</title>
      <link>https://www.javai.net/post/202204/undirected-graphs/</link>
      <pubDate>Wed, 06 Apr 2022 13:57:30 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/undirected-graphs/</guid>
      <description>Basic concepts Definition of a graph A graph is a binary consisting of a set of points V={vi}V={vi} and a set E={ek}E={ek} of unordered pairs of elements in VV, denoted G=(V,E)G=(V,E), elements vivi in VV are called vertices and elements ekek in EE are called edges.
For two points u,vu,v in VV, if the edge (u,v)(u,v) belongs to EE, then the two points u,vu,v are said to be adjacent and u,vu,v is called the endpoint of the edge (u,v)(u,v).</description>
    </item>
    
    <item>
      <title>Usage of Bigdecimal</title>
      <link>https://www.javai.net/post/202204/bigdecimal-use/</link>
      <pubDate>Tue, 05 Apr 2022 20:26:02 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/bigdecimal-use/</guid>
      <description>As a Java developer in the daily work, many times we will encounter some need to calculate the data scenario, usually for the scenario does not need to calculate the precision we can use Integer, Float or Double to calculate, although will lose precision but occasionally can be used, if we need to calculate the results accurately, we will use the class BigDecimal provided in the java.math package to implement the corresponding function.</description>
    </item>
    
    <item>
      <title>How to estimate throughput and thread pool size</title>
      <link>https://www.javai.net/post/202204/threadpool-size/</link>
      <pubDate>Mon, 04 Apr 2022 17:35:33 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/threadpool-size/</guid>
      <description>Estimating Throughput Now there is a task which execution time is divided into 2 parts, the first part does math and the second part waits for IO. these two parts are called compute operation and wait operation.
So now we need to estimate the peak throughput that can be achieved by executing this task with the CPU at full power.
Then we need to know how much time it takes to execute this task, how much time is spent on the computation part and how much time is spent on the wait part.</description>
    </item>
    
    <item>
      <title>Java generates a lot of zombie process problems</title>
      <link>https://www.javai.net/post/202204/java-zombie-processes/</link>
      <pubDate>Mon, 04 Apr 2022 17:07:11 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-zombie-processes/</guid>
      <description>Recently I encountered a problem, a Java process using Runtime().exec() to execute script files, creating a large number of zombie processes, while the Java process is running in the container.
At that time, I saw this situation on the Host machine, and I could see that there were a large number of zombie processes.
Locate the zombie process by ps aux | grep Z.
1 2 3 4 5 6 7 8 9  USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 2518 0.</description>
    </item>
    
    <item>
      <title>Practical application scenarios for pipeline stream</title>
      <link>https://www.javai.net/post/202204/piped-stream/</link>
      <pubDate>Sun, 03 Apr 2022 15:17:30 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/piped-stream/</guid>
      <description>Preface PipedInputStream and PipedOutputStream are designed to solve cross-thread byte data transfers. They always come in pairs and can only be used on two different threads, using piped input and output streams in one thread can cause deadlocks. In some business scenarios, using pipeline streams will increase the speed of file uploads and reduce CPU and IO overhead, this is very practical, so this article talks about Practical application scenarios for pipeline stream.</description>
    </item>
    
    <item>
      <title>Principle of implementation of atomic operations</title>
      <link>https://www.javai.net/post/202204/atomic-principle/</link>
      <pubDate>Sat, 02 Apr 2022 16:00:46 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/atomic-principle/</guid>
      <description>1. Introduction Atomic means &amp;ldquo;the smallest particle that cannot be further divided&amp;rdquo;, and atomic operation means &amp;ldquo;an operation or series of operations that cannot be interrupted&amp;rdquo;. Implementing atomic operations on a multiprocessor becomes a bit complicated. In this article, let&amp;rsquo;s talk about how atomic operations are implemented on Intel processors and in Java.
2. Definition of Terms Compare and Swap CAS operations require two values to be entered, an old value (the value before the desired operation) and a new value, during which the old value is compared to the new value if it has not changed, and not exchanged if it.</description>
    </item>
    
    <item>
      <title>Spring Framework RCE Solution</title>
      <link>https://www.javai.net/post/202204/spring-framework-rce-solution/</link>
      <pubDate>Fri, 01 Apr 2022 22:47:06 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/spring-framework-rce-solution/</guid>
      <description>Just yesterday Spring officially announced a Spring Framework RCE vulnerability CVE-2022-22965.
Upgrading to Spring Framework 5.3.18+ or 5.2.20+ remains the main official Spring recommendation, which officially claims to address the root cause and prevent some other vulnerability attacks, and these also provide fixes for other CVEs.
Although the vulnerability is not in Tomcat itself, the Apache Tomcat team has also released versions 10.0.20, 9.0.62 and 8.5.78 with it, which are the official Tomcat solutions for the reported CVE-2022-22965 vulnerability, which has been addressed in the above versions, for older The above version has resolved the CVE-2022-22965 vulnerability, and for older, unsupported versions of Spring Framework, the vulnerability can be circumvented by upgrading the Tomcat version.</description>
    </item>
    
    <item>
      <title>Thread pool rejection policy</title>
      <link>https://www.javai.net/post/202204/thread-pool-rejection-strategy/</link>
      <pubDate>Fri, 01 Apr 2022 14:10:49 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/thread-pool-rejection-strategy/</guid>
      <description>Preface When it comes to java thread pools nothing is more familiar than the ExecutorService interface. jdk1.5 adds java.util.concurrent package under this api, which greatly simplifies the development of multi-threaded code. Whether you use FixedThreadPool or CachedThreadPool the implementation behind it is ThreadPoolExecutor. threadPoolExecutor is a typical product of cache pooling design, because the pool has a size, when the pool volume is not enough to carry, it involves a rejection policy.</description>
    </item>
    
    <item>
      <title>Java reflection mechanism</title>
      <link>https://www.javai.net/post/202203/java-reflect/</link>
      <pubDate>Thu, 31 Mar 2022 15:53:34 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202203/java-reflect/</guid>
      <description>What is Reflection In the runtime state, for any class, you can know all the properties and methods of the class; for any object, you can call any of its methods and properties; this dynamically obtained information and dynamic invocation of the object&amp;rsquo;s methods is called the reflection mechanism of the Java language. So what can we do with reflection?
 Analyze classes at runtime. Look at objects at runtime. We can also use reflection to write a toString method for all classes to use.</description>
    </item>
    
    <item>
      <title>A scenario using Threadlocal to solve concurrency and efficiency problems</title>
      <link>https://www.javai.net/post/202203/threadlocal-use/</link>
      <pubDate>Wed, 30 Mar 2022 20:39:02 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202203/threadlocal-use/</guid>
      <description>ThreadLocal is a tool provided by JDK 1.2, a tool mainly to solve the problem of sharing resources under multi-threaded, In the next section, we will analyze how ThreadLocal can be used to solve concurrency problems and improve code efficiency in development, starting from the definition of ThreadLocal and its application scenarios.
Scenario 1, ThreadLocal is used to save objects that are unique to each thread, creating a copy for each thread so that each thread can modify the copy it owns without affecting the other threads&amp;rsquo; copies, ensuring thread safety.</description>
    </item>
    
    <item>
      <title>A common defect in java systems - Memory DoS</title>
      <link>https://www.javai.net/post/202203/memory-dos/</link>
      <pubDate>Tue, 29 Mar 2022 20:09:45 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202203/memory-dos/</guid>
      <description>I. What is DoS? DoS is short for Denial of Service, which means denial of service. The attack that causes DoS is called a DoS attack, and its purpose is to make the computer or network unable to provide normal services. Denial of Service exists on various web services, this web service can be implemented in c, c++, or go, java, php, python, and other languages.
II. Status of Java DoS In various open source and closed source java system products, we often see announcements about DoS defects, most of which are CPU exhaustion type or business offload type DoS.</description>
    </item>
    
    <item>
      <title>Using encryption and decryption in Java</title>
      <link>https://www.javai.net/post/202203/huttol-crypto/</link>
      <pubDate>Mon, 28 Mar 2022 21:48:49 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202203/huttol-crypto/</guid>
      <description>Instructions In project development, in order to ensure the security of data and user privacy, we usually encrypt key information, this article details how to use hutool in java language to quickly encrypt and decrypt data, hope you can help.
If your project is built on Maven, you can introduce Hutool through pom to use the encryption and decryption function.
1 2 3 4 5  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;cn.hutool&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hutool-crypto&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.7.15&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;   If your project is not built based on maven, you can also directly download the jar package to use.</description>
    </item>
    
    <item>
      <title>Java Startup Params</title>
      <link>https://www.javai.net/post/202203/java-startup-params/</link>
      <pubDate>Sun, 27 Mar 2022 19:42:45 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202203/java-startup-params/</guid>
      <description>Basic Format Run java -help to see the basic format and options
1 2 3 4 5 6 7 8  [root@localhost ~]# java -help Usage: java [-options] class [args...] (execute class) or java [-options] -jar jarfile [args...] (execute jar file) Startup options are omitted [-options]: options [-options]: options [args...] : Passes a parameter to the main method   Standard options  -help / -? : output help information -version : output version information -classpath / -cp: class search path for directories and zip/jar files .</description>
    </item>
    
    <item>
      <title>JavaNIO and Zero Copy</title>
      <link>https://www.javai.net/post/202203/zero-copy/</link>
      <pubDate>Sat, 26 Mar 2022 21:46:31 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202203/zero-copy/</guid>
      <description>Zero-copy in the Linux operating system Let&amp;rsquo;s start with the general I/O process of Linux This is a procedure that reads from a disk file and writes to it via socket, and the corresponding system call is as follows.
1 2  read(file, tmp_buf, len); write(socket, tmp_buf, len);   The program uses the read() system call to change the system from user state to kernel state, and the data from the disk is read into the kernel buffer by means of DMA (Direct memory access).</description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>throughput on JavaIsland</title>
    <link>https://www.javai.net/tags/throughput/</link>
    <description>Recent content in throughput on JavaIsland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 15 Apr 2022 20:59:32 +0800</lastBuildDate><atom:link href="https://www.javai.net/tags/throughput/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java Virtual Threads Explained</title>
      <link>https://www.javai.net/post/202204/java-virtual-threads-explained/</link>
      <pubDate>Fri, 15 Apr 2022 20:59:32 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-virtual-threads-explained/</guid>
      <description>Many languages have technologies like virtual threads, such as Go, C#, Erlang, Lua, etc, which they call concurrent threads. Whether they are virtual threads or concurrent threads, they are all lightweight threads that aim to improve concurrency. This section details the Java platform&amp;rsquo;s virtual threads technology, JEP 425: Virtual Threads (Preview).
The Java platform plans to introduce virtual threads that will significantly reduce the effort of writing, maintaining, and observing high-throughput concurrent applications.</description>
    </item>
    
    <item>
      <title>Java introduces preview virtual threads</title>
      <link>https://www.javai.net/post/202204/java-virtual-threads/</link>
      <pubDate>Fri, 08 Apr 2022 13:14:35 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-virtual-threads/</guid>
      <description>OpenJDK&amp;rsquo;s JEP 425: Virtual Threads (Preview) feature proposal shows that the Java platform will introduce the virtual threads feature. Virtual threads are lightweight threads that can significantly reduce the effort of writing, maintaining, and observing high-throughput concurrent applications.
Java developers have always relied on threads as the building blocks of concurrent server applications, where statements in each method are executed within a thread, and each thread provides a stack to store local variables and coordinate method calls, as well as context trapping when errors are reported.</description>
    </item>
    
    <item>
      <title>How to estimate throughput and thread pool size</title>
      <link>https://www.javai.net/post/202204/threadpool-size/</link>
      <pubDate>Mon, 04 Apr 2022 17:35:33 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/threadpool-size/</guid>
      <description>Estimating Throughput Now there is a task which execution time is divided into 2 parts, the first part does math and the second part waits for IO. these two parts are called compute operation and wait operation.
So now we need to estimate the peak throughput that can be achieved by executing this task with the CPU at full power.
Then we need to know how much time it takes to execute this task, how much time is spent on the computation part and how much time is spent on the wait part.</description>
    </item>
    
  </channel>
</rss>

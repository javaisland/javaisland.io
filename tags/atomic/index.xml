<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>atomic on JavaIsland</title>
    <link>https://www.javai.net/tags/atomic/</link>
    <description>Recent content in atomic on JavaIsland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 19 Apr 2022 15:11:02 +0800</lastBuildDate><atom:link href="https://www.javai.net/tags/atomic/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AbstractQueuedSynchronizer implementation principle - 2</title>
      <link>https://www.javai.net/post/202204/java-aqs-principle-2/</link>
      <pubDate>Tue, 19 Apr 2022 15:11:02 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-aqs-principle-2/</guid>
      <description>Preface In the previous articleAbstractQueuedSynchronizer implementation principle - 1, we explained the acquisition and release of exclusive synchronization state in AbstractQueuedSynchronizer, and here we start to explain the acquisition and release of shared synchronization state in AbstractQueuedSynchronizer.
Shared Synchronous State Acquisition and Release Shared lock as the name implies is that multiple threads can share a lock, use acquireShared in the synchronizer to get the shared lock (synchronous state), the source code of the method is as follows.</description>
    </item>
    
    <item>
      <title>AbstractQueuedSynchronizer implementation principle - 1</title>
      <link>https://www.javai.net/post/202204/java-aqs-principle-1/</link>
      <pubDate>Tue, 19 Apr 2022 14:29:23 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-aqs-principle-1/</guid>
      <description>Preface AbstractQueuedSynchronizer is the basic framework for implementing concurrency tools in the JDK, and a deeper understanding of it will help us to better use its features and related tools. We hope you will read this article carefully and gain something from it.
In Java, access to shared resources by multiple threads is controlled by lock. We know that the lock function can be implemented by the synchronized keyword, which can implicitly acquire locks, that is, we do not need to care about the process of acquiring and releasing locks by using this keyword, but while it provides convenience, it also means that its flexibility is reduced.</description>
    </item>
    
    <item>
      <title>Simple use of the Atomic class</title>
      <link>https://www.javai.net/post/202204/java-atomic-class/</link>
      <pubDate>Mon, 18 Apr 2022 17:14:34 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-atomic-class/</guid>
      <description>Problem Background In a multi-threaded environment, the most common problem we encounter is synchronizing the values of variables. Since variables need to be shared across multiple threads, we must need to employ some synchronization mechanism to control them.
From the previous article we know that the Lock mechanism can be used, and of course, the Atomic class we are talking about today.
Here we will introduce each of the two ways.</description>
    </item>
    
    <item>
      <title>Principle of implementation of atomic operations</title>
      <link>https://www.javai.net/post/202204/atomic-principle/</link>
      <pubDate>Sat, 02 Apr 2022 16:00:46 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/atomic-principle/</guid>
      <description>1. Introduction Atomic means &amp;ldquo;the smallest particle that cannot be further divided&amp;rdquo;, and atomic operation means &amp;ldquo;an operation or series of operations that cannot be interrupted&amp;rdquo;. Implementing atomic operations on a multiprocessor becomes a bit complicated. In this article, let&amp;rsquo;s talk about how atomic operations are implemented on Intel processors and in Java.
2. Definition of Terms Compare and Swap CAS operations require two values to be entered, an old value (the value before the desired operation) and a new value, during which the old value is compared to the new value if it has not changed, and not exchanged if it.</description>
    </item>
    
  </channel>
</rss>

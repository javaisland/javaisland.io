<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on JavaIsland</title>
    <link>https://www.javai.net/tags/java/</link>
    <description>Recent content in java on JavaIsland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 11 Apr 2022 15:57:29 +0800</lastBuildDate><atom:link href="https://www.javai.net/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Better use of Java thread pool</title>
      <link>https://www.javai.net/post/202204/thread-pool-tips/</link>
      <pubDate>Mon, 11 Apr 2022 15:57:29 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/thread-pool-tips/</guid>
      <description>Introduction This article combines the JUC package provided by Doug Lea in JDK1.5 to understand the use of thread pools from the setting of thread pool size parameters, the creation of work threads, the recycling of idle threads, the use of blocking queues, task rejection strategies, thread pool Hook and other aspects, which involves some details including the choice of different parameters, different queues, different rejection strategies, the resulting The details include the different parameters, the different queues, the choice of different rejection strategies, the resulting impact and behavior, and for better use of the thread pool.</description>
    </item>
    
    <item>
      <title>Technology Trends Java Teams Should Watch in 2022</title>
      <link>https://www.javai.net/post/202204/java-2022-trends/</link>
      <pubDate>Mon, 11 Apr 2022 15:33:15 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-2022-trends/</guid>
      <description>Java is evolving quickly, and with potential changes to the OpenJDK release cycle, it may accelerate even further. For people like Michael Rasmussen, JRebel development lead at Perforce, keeping up with these changes and understanding their impact on development; creating features that resonate with the Java development community, keeping applications up to date with the latest versions of popular Java technologies, and developing new features, improvements, and integrations for JRebel is critical.</description>
    </item>
    
    <item>
      <title>Analysis of connection pooling principles through HiKariCP</title>
      <link>https://www.javai.net/post/202204/java-hikaricp/</link>
      <pubDate>Mon, 11 Apr 2022 13:54:22 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-hikaricp/</guid>
      <description>Design and Principle The base case HiKariCP as the default connection pool of SpringBoot2 framework, claimed to be the fastest running connection pool, database connection pool and the previous two mentioned thread pool and object pool, from the principle of design are based on the pooling idea, only in the implementation of their own characteristics; first or see the basic case of HiKariCP usage.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import com.</description>
    </item>
    
    <item>
      <title>Synchronized keywords in java concurrency</title>
      <link>https://www.javai.net/post/202204/java-synchronized/</link>
      <pubDate>Mon, 11 Apr 2022 10:26:19 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-synchronized/</guid>
      <description>Introduction In a multi-threaded environment, we often encounter resource competition, such as multiple threads going to modify the same shared variable at the same time, it is necessary to perform some processing of the resource access method to ensure that only one thread accesses it at the same time.
Java provides the synchronized keyword to facilitate us to achieve the above operation.
Why synchronized Let&amp;rsquo;s take an example where we create a class that provides a setSum method.</description>
    </item>
    
    <item>
      <title>Difference between wait and sleep in java</title>
      <link>https://www.javai.net/post/202204/java-wait-sleep/</link>
      <pubDate>Sun, 10 Apr 2022 22:19:20 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-wait-sleep/</guid>
      <description>Introduction In this post, we will discuss the difference between wait() and sleep() methods in java. And discuss how to use these two methods.
Difference between wait and sleep wait() is a native method defined in Object.
1  public final native void wait(long timeout) throws InterruptedException;   So every instance of the class can call this method. wait() can only be called in a synchronized block. It will release the lock put on the object when it is synchronized.</description>
    </item>
    
    <item>
      <title>Advanced Usage of java - Function in JNA</title>
      <link>https://www.javai.net/post/202204/java-jna-function/</link>
      <pubDate>Sun, 10 Apr 2022 21:59:57 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-jna-function/</guid>
      <description>Introduction In JNA, in order to map with native functions, we can have two mapping methods, the first one is interface mapping and the second one is direct mapping. Although the two approaches are different, in the specific method mapping, we both need to define a method in JAVA that maps to the native method..
This JAVA mapping is a function in JNA, and by using a function object, we can achieve some very powerful functionality.</description>
    </item>
    
    <item>
      <title>Java Zombie Processes Continued</title>
      <link>https://www.javai.net/post/202204/java-zombie-processes-continued/</link>
      <pubDate>Sat, 09 Apr 2022 15:26:12 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-zombie-processes-continued/</guid>
      <description>In a previous article, I mentioned the problem of Java program containers generating a lot of zombie processes. Today I ran into it again, but in a different way.
The zombie processes are also generated by a bash script, but this script is executed in the K8S readinessProbe and livenessProbe, not by the java program itself.
Let&amp;rsquo;s look at some failure diagrams.
You can see that there are many timeout processes that are not cleaned up after execution.</description>
    </item>
    
    <item>
      <title>Java introduces preview virtual threads</title>
      <link>https://www.javai.net/post/202204/java-virtual-threads/</link>
      <pubDate>Fri, 08 Apr 2022 13:14:35 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-virtual-threads/</guid>
      <description>OpenJDK&amp;rsquo;s JEP 425: Virtual Threads (Preview) feature proposal shows that the Java platform will introduce the virtual threads feature. Virtual threads are lightweight threads that can significantly reduce the effort of writing, maintaining, and observing high-throughput concurrent applications.
Java developers have always relied on threads as the building blocks of concurrent server applications, where statements in each method are executed within a thread, and each thread provides a stack to store local variables and coordinate method calls, as well as context trapping when errors are reported.</description>
    </item>
    
    <item>
      <title>Application of Volatile</title>
      <link>https://www.javai.net/post/202204/volatile-application/</link>
      <pubDate>Thu, 07 Apr 2022 16:01:20 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/volatile-application/</guid>
      <description>Memory Visibility Since the Java Memory Model (JMM) states that all variables are stored in main memory, and each thread has its own working memory (cache).
When a thread is working, it needs to copy the data from the main memory to the working memory. This way, any operation on the data is based on the working memory (which is more efficient) and cannot directly manipulate the data in the main memory or the working memory of other threads, and then flush the updated data to the main memory afterwards.</description>
    </item>
    
    <item>
      <title>ReentrantLock implementation principle</title>
      <link>https://www.javai.net/post/202204/reentrantlock-principle/</link>
      <pubDate>Wed, 06 Apr 2022 16:30:46 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/reentrantlock-principle/</guid>
      <description>When using synchronize to do synchronization, lock acquisition and release are implicitly implemented by compiling and adding different machine instructions to achieve the principle.
 ReentrantLock is a class based on AbstractQueuedSynchronizer(AQS for short) implementation, this article analyzes the implementation principle of ReentrantLock, I hope it will be helpful to you.
ReentrantLock: a thread can still repeat the lock after it has obtained it, and will not appear to block itself.</description>
    </item>
    
    <item>
      <title>Practical Applications of Reflection - Building Log Objects</title>
      <link>https://www.javai.net/post/202204/java-reflect-application/</link>
      <pubDate>Wed, 06 Apr 2022 16:16:21 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-reflect-application/</guid>
      <description>Preface In our practical development, we often use reflection, I present an example of the logging function done by reflection in practical development.
Traditional logging Some basic knowledge about reflection can be found in Reflection Primer.
I believe that logging is not new to you, in the actual development of some more sensitive data tables we need to record every operation of it.
First, let&amp;rsquo;s look at the traditional way of writing.</description>
    </item>
    
    <item>
      <title>How to implement detection of undirected and directed loops in Java</title>
      <link>https://www.javai.net/post/202204/detect-loops/</link>
      <pubDate>Wed, 06 Apr 2022 13:59:55 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/detect-loops/</guid>
      <description>Undirected rings An undirected graph with rings is shown below, where there are two rings, 0-2-1-0 and 2-3-4-2, respectively.
To detect rings in an undirected graph, you can use depth-first search. Suppose we start from vertex 0, then walk to the adjacent vertex 2, then walk to the vertex 1 adjacent to vertex 2. Since vertex 0 and vertex 1 are adjacent and vertex 0 is labeled, it means we have spared a loop, so there is a loop in the undirected graph.</description>
    </item>
    
    <item>
      <title>How to implement undirected graphs in Java</title>
      <link>https://www.javai.net/post/202204/undirected-graphs/</link>
      <pubDate>Wed, 06 Apr 2022 13:57:30 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/undirected-graphs/</guid>
      <description>Basic concepts Definition of a graph A graph is a binary consisting of a set of points V={vi}V={vi} and a set E={ek}E={ek} of unordered pairs of elements in VV, denoted G=(V,E)G=(V,E), elements vivi in VV are called vertices and elements ekek in EE are called edges.
For two points u,vu,v in VV, if the edge (u,v)(u,v) belongs to EE, then the two points u,vu,v are said to be adjacent and u,vu,v is called the endpoint of the edge (u,v)(u,v).</description>
    </item>
    
    <item>
      <title>Usage of Bigdecimal</title>
      <link>https://www.javai.net/post/202204/bigdecimal-use/</link>
      <pubDate>Tue, 05 Apr 2022 20:26:02 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/bigdecimal-use/</guid>
      <description>As a Java developer in the daily work, many times we will encounter some need to calculate the data scenario, usually for the scenario does not need to calculate the precision we can use Integer, Float or Double to calculate, although will lose precision but occasionally can be used, if we need to calculate the results accurately, we will use the class BigDecimal provided in the java.math package to implement the corresponding function.</description>
    </item>
    
    <item>
      <title>Java8 new features of the time and date API</title>
      <link>https://www.javai.net/post/202204/java8-time-api/</link>
      <pubDate>Tue, 05 Apr 2022 17:40:16 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java8-time-api/</guid>
      <description>Java8 includes a new time and date API, which is placed under the java.time package. This new time-date API is immutable and thread-safe (This class is immutable and thread-safe).
Local time: LocalDate, LocalTime, LocalDateTime Instances of the classes localDate, LocalTime, and LocalDateTime are immutable objects that represent the date, time, date, and time, respectively, using the ISO-8601 calendar system. They provide a simple date or time and do not contain current time information.</description>
    </item>
    
    <item>
      <title>How to estimate throughput and thread pool size</title>
      <link>https://www.javai.net/post/202204/threadpool-size/</link>
      <pubDate>Mon, 04 Apr 2022 17:35:33 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/threadpool-size/</guid>
      <description>Estimating Throughput Now there is a task which execution time is divided into 2 parts, the first part does math and the second part waits for IO. these two parts are called compute operation and wait operation.
So now we need to estimate the peak throughput that can be achieved by executing this task with the CPU at full power.
Then we need to know how much time it takes to execute this task, how much time is spent on the computation part and how much time is spent on the wait part.</description>
    </item>
    
    <item>
      <title>Changes to the String object in Java 9</title>
      <link>https://www.javai.net/post/202204/java9-string/</link>
      <pubDate>Mon, 04 Apr 2022 17:27:47 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java9-string/</guid>
      <description>Overview In Java 9, the underlying String object has been changed from char[] to byte[], which has the immediate benefit of being more memory-efficient, hence the name Compact Strings Improvement. Because in Java char takes up 2 bytes and byte takes up 1 byte, while a Unicode character does not necessarily need 2 bytes to be represented, at least ASCII characters only need 1 byte to be done. That is, if your string is full of ASCII characters, half the space would be wasted if you use char.</description>
    </item>
    
    <item>
      <title>Java generates a lot of zombie process problems</title>
      <link>https://www.javai.net/post/202204/java-zombie-processes/</link>
      <pubDate>Mon, 04 Apr 2022 17:07:11 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-zombie-processes/</guid>
      <description>Recently I encountered a problem, a Java process using Runtime().exec() to execute script files, creating a large number of zombie processes, while the Java process is running in the container.
At that time, I saw this situation on the Host machine, and I could see that there were a large number of zombie processes.
Locate the zombie process by ps aux | grep Z.
1 2 3 4 5 6 7 8 9  USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 2518 0.</description>
    </item>
    
    <item>
      <title>Practical application scenarios for pipeline stream</title>
      <link>https://www.javai.net/post/202204/piped-stream/</link>
      <pubDate>Sun, 03 Apr 2022 15:17:30 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/piped-stream/</guid>
      <description>Preface PipedInputStream and PipedOutputStream are designed to solve cross-thread byte data transfers. They always come in pairs and can only be used on two different threads, using piped input and output streams in one thread can cause deadlocks. In some business scenarios, using pipeline streams will increase the speed of file uploads and reduce CPU and IO overhead, this is very practical, so this article talks about Practical application scenarios for pipeline stream.</description>
    </item>
    
    <item>
      <title>Principle of implementation of atomic operations</title>
      <link>https://www.javai.net/post/202204/atomic-principle/</link>
      <pubDate>Sat, 02 Apr 2022 16:00:46 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/atomic-principle/</guid>
      <description>1. Introduction Atomic means &amp;ldquo;the smallest particle that cannot be further divided&amp;rdquo;, and atomic operation means &amp;ldquo;an operation or series of operations that cannot be interrupted&amp;rdquo;. Implementing atomic operations on a multiprocessor becomes a bit complicated. In this article, let&amp;rsquo;s talk about how atomic operations are implemented on Intel processors and in Java.
2. Definition of Terms Compare and Swap CAS operations require two values to be entered, an old value (the value before the desired operation) and a new value, during which the old value is compared to the new value if it has not changed, and not exchanged if it.</description>
    </item>
    
  </channel>
</rss>

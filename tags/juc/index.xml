<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>juc on JavaIsland</title>
    <link>https://www.javai.net/tags/juc/</link>
    <description>Recent content in juc on JavaIsland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 11 Apr 2022 15:57:29 +0800</lastBuildDate><atom:link href="https://www.javai.net/tags/juc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Better use of Java thread pool</title>
      <link>https://www.javai.net/post/202204/thread-pool-tips/</link>
      <pubDate>Mon, 11 Apr 2022 15:57:29 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/thread-pool-tips/</guid>
      <description>Introduction This article combines the JUC package provided by Doug Lea in JDK1.5 to understand the use of thread pools from the setting of thread pool size parameters, the creation of work threads, the recycling of idle threads, the use of blocking queues, task rejection strategies, thread pool Hook and other aspects, which involves some details including the choice of different parameters, different queues, different rejection strategies, the resulting The details include the different parameters, the different queues, the choice of different rejection strategies, the resulting impact and behavior, and for better use of the thread pool.</description>
    </item>
    
    <item>
      <title>Synchronized keywords in java concurrency</title>
      <link>https://www.javai.net/post/202204/java-synchronized/</link>
      <pubDate>Mon, 11 Apr 2022 10:26:19 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-synchronized/</guid>
      <description>Introduction In a multi-threaded environment, we often encounter resource competition, such as multiple threads going to modify the same shared variable at the same time, it is necessary to perform some processing of the resource access method to ensure that only one thread accesses it at the same time.
Java provides the synchronized keyword to facilitate us to achieve the above operation.
Why synchronized Let&amp;rsquo;s take an example where we create a class that provides a setSum method.</description>
    </item>
    
    <item>
      <title>Difference between wait and sleep in java</title>
      <link>https://www.javai.net/post/202204/java-wait-sleep/</link>
      <pubDate>Sun, 10 Apr 2022 22:19:20 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202204/java-wait-sleep/</guid>
      <description>Introduction In this post, we will discuss the difference between wait() and sleep() methods in java. And discuss how to use these two methods.
Difference between wait and sleep wait() is a native method defined in Object.
1  public final native void wait(long timeout) throws InterruptedException;   So every instance of the class can call this method. wait() can only be called in a synchronized block. It will release the lock put on the object when it is synchronized.</description>
    </item>
    
  </channel>
</rss>

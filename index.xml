<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaIsland</title>
    <link>https://www.javai.net/</link>
    <description>Recent content on JavaIsland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 27 Mar 2022 19:42:45 +0800</lastBuildDate>
    
        <atom:link href="https://www.javai.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://www.javai.net/about/</link>
      <pubDate>Sat, 26 Mar 2022 21:46:31 +0800</pubDate>
      
      <guid>https://www.javai.net/about/</guid>
      
        <description>&lt;p&gt;Welcome to JavaIsland, where many technical articles related to Java technology are produced, we hope the articles here can bring you some help&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Some of the content is collected from the Internet, and we apologize if it inadvertently infringes on your copyright. Please contact us. We will remove it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;java-development-related-websites&#34;&gt;Java development related websites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://java.com&#34;&gt;https://java.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mysql.com&#34;&gt;https://www.mysql.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io&#34;&gt;https://spring.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://redis.io&#34;&gt;https://redis.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nginx.com&#34;&gt;https://www.nginx.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Java Startup Params</title>
      <link>https://www.javai.net/post/202203/java-startup-params/</link>
      <pubDate>Sun, 27 Mar 2022 19:42:45 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202203/java-startup-params/</guid>
      
        <description>&lt;h2 id=&#34;basic-format&#34;&gt;Basic Format&lt;/h2&gt;
&lt;p&gt;Run java -help to see the basic format and options&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;root@localhost ~&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# java -help&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Usage: java &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-options&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; class &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;args...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;execute class&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   or java &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-options&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; -jar jarfile &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;args...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;execute jar file&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Startup options are omitted
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-options&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: options
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-options&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: options &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;args...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; : Passes a parameter to the main method
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;standard-options&#34;&gt;Standard options&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-help / -? &lt;/code&gt;: output help information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-version&lt;/code&gt; : output version information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-classpath / -cp&lt;/code&gt;: class search path for directories and &lt;code&gt;zip/jar&lt;/code&gt; files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;... &lt;/code&gt; Other uncommon parameters&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;non-standard-options-the-x-parameter&#34;&gt;Non-standard options (the &lt;code&gt;X&lt;/code&gt; parameter)&lt;/h2&gt;
&lt;h3 id=&#34;compile-mode-options&#34;&gt;Compile mode options.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Xint&lt;/code&gt; : interpreted mode execution only&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Xcomp&lt;/code&gt;: opposite of &lt;code&gt;-Xint&lt;/code&gt;, fully compile on first use&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Xmixed&lt;/code&gt; : (default) mixed mode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Examples of the three modes of JVM operation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/javaisland/images/2022/03/27/d30b3ce5bf464f07a805282ce03b461c.png&#34; alt=&#34;Example of operation mode&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;abbreviated-options-for-advanced-options-xx-parameters&#34;&gt;Abbreviated options for advanced options (&lt;code&gt;xx&lt;/code&gt; parameters)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Xms&lt;/code&gt;: Sets the minimum and initial size of the heap. This parameter is equal to &lt;code&gt;-XX:InitialHeapSize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Xmx&lt;/code&gt;: Sets the maximum size of the heap, &lt;code&gt;-Xms&lt;/code&gt; is usually set to the same value as &lt;code&gt;-Xmx&lt;/code&gt;. This parameter is equal to &lt;code&gt;-XX:MaxHeapSize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Xmn&lt;/code&gt; : Sets the initial and maximum size of the young Generation heap. This parameter is equal to setting both &lt;code&gt;-XX:NewSize&lt;/code&gt; and &lt;code&gt;-XX:MaxNewSize&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Xss&lt;/code&gt;: Sets the individual thread stack size, typically &lt;code&gt;512k ~ 1024k&lt;/code&gt;. This parameter is equal to the same as &lt;code&gt;-XX:ThreadStackSize&lt;/code&gt;. The default values are as follows: (depends on the platform)
&lt;ul&gt;
&lt;li&gt;Linux/ARM (32-bit): 320 KB&lt;/li&gt;
&lt;li&gt;Linux/i386 (32-bit): 320 KB&lt;/li&gt;
&lt;li&gt;Linux/x64 (64-bit): 1024 KB&lt;/li&gt;
&lt;li&gt;OS X (64-bit): 1024 KB&lt;/li&gt;
&lt;li&gt;Oracle Solaris/i386 (32-bit): 320 KB&lt;/li&gt;
&lt;li&gt;Oracle Solaris/x64 (64-bit): 1024 KB&lt;/li&gt;
&lt;li&gt;Windows: determined by virtual memory&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;advanced-options-xx-parameters&#34;&gt;Advanced options (&lt;code&gt;XX&lt;/code&gt; parameters)&lt;/h2&gt;
&lt;h3 id=&#34;classification-methods&#34;&gt;Classification methods&lt;/h3&gt;
&lt;p&gt;According to the official classification, there are four types as follows&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Advanced Runtime Options&lt;/li&gt;
&lt;li&gt;Advanced JIT Compiler Options&lt;/li&gt;
&lt;li&gt;Advanced Serviceability Options&lt;/li&gt;
&lt;li&gt;Advanced Garbage Collection Option&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;According to the classification of the way to set parameters, there are two types as follows&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Boolean&lt;/code&gt; type.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-XX:+&lt;/code&gt; means on&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:-&lt;/code&gt; means off&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;KV&lt;/code&gt; set value type: &lt;code&gt;-XX:Key=Value&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Capacity type (no &lt;code&gt;B&lt;/code&gt; suffix is allowed)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt; or &lt;code&gt;K&lt;/code&gt; for &lt;code&gt;KB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; or &lt;code&gt;M&lt;/code&gt; for &lt;code&gt;MB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; or &lt;code&gt;G&lt;/code&gt; for &lt;code&gt;GB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Numeric unitless representation &lt;code&gt;B&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Numeric
&lt;ul&gt;
&lt;li&gt;Size&lt;/li&gt;
&lt;li&gt;Proportional&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;common-settings&#34;&gt;Common settings&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-XX:+PrintCommandLineFlags&lt;/code&gt; : Enables printing of JVM configuration on the command line, such as heap space size and the selected garbage collector. Disabled by default.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:MetaspaceSize=size&lt;/code&gt; : Sets the size of the metadata space that will trigger garbage collection when it is exceeded for the first time. This threshold for garbage collection increases or decreases depending on the amount of metadata in use. The default size depends on the platform.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:MaxMetaspaceSize=size&lt;/code&gt; : Sets the maximum amount of native memory for metadata. By default, there is no limit on the size. The amount of application metadata depends on the application itself, other running applications, and the amount of memory available in the system.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:SurvivorRatio=ratio&lt;/code&gt;: Sets the ratio between the size of &lt;code&gt;Eden&lt;/code&gt; space and the size of &lt;code&gt;Survivor&lt;/code&gt; space. The default value is 8, i.e. &lt;code&gt;Eden:S0:S1&lt;/code&gt; = 8:1:1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/javaisland/images/2022/03/27/374169b48abe489e9d0f9a31317dbe32.jpg&#34; alt=&#34;Heap Setup Lifecycle&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Xms -Xmx&lt;/code&gt; : Usually set to the same value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Xmx&lt;/code&gt; : Young Generation heap region is used for new objects. This area performs &lt;code&gt;GC&lt;/code&gt; more often than other areas. If the young generation is too small, then &lt;code&gt;Young GC&lt;/code&gt; will be executed frequently. If it is too large, then only &lt;code&gt;Full GC&lt;/code&gt; will be executed, which may take a long time to complete. &lt;code&gt;Oracle&lt;/code&gt; recommends keeping the young generation heap size between half and a quarter of the overall heap size&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Xss&lt;/code&gt;: generally set to &lt;code&gt;1M&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:+PrintCommandLineFlags&lt;/code&gt; : recommended to enable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:MetaspaceSize=size -XX:MaxMetaspaceSize=size&lt;/code&gt; : Generally &lt;code&gt;256M&lt;/code&gt; is sufficient&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:SurvivorRatio=ratio&lt;/code&gt; : default value is 8, recommended to add&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is recommended to lower the value of the above startup parameters when the virtual machine is running low on resources,for example.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;java -XX:+PrintCommandLineFlags -Xms128M -Xmx128M -Xmn64M -XX:MetaspaceSize&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;256M -XX:MaxMetaspaceSize&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;256M -XX:SurvivorRatio&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; -jar web.jar
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>JavaNIO and Zero Copy</title>
      <link>https://www.javai.net/post/202203/zero-copy/</link>
      <pubDate>Sat, 26 Mar 2022 21:46:31 +0800</pubDate>
      
      <guid>https://www.javai.net/post/202203/zero-copy/</guid>
      
        <description>&lt;h2 id=&#34;zero-copy-in-the-linux-operating-system&#34;&gt;Zero-copy in the Linux operating system&lt;/h2&gt;
&lt;h3 id=&#34;lets-start-with-the-general-io-process-of-linux&#34;&gt;Let&amp;rsquo;s start with the general I/O process of Linux&lt;/h3&gt;
&lt;p&gt;This is a procedure that reads from a disk file and writes to it via socket, and the corresponding system call is as follows.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tmp_buf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tmp_buf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div align=center&gt; &lt;img alt=&#34;System call flow chart&#34; src=&#34;https://cdn.jsdelivr.net/gh/javaisland/images/2022/03/26/240d80bbe51a4960851e81b4f00a0b12.jpg&#34;/&gt; &lt;/div&gt;
&lt;p&gt;The program uses the read() system call to change the system from user state to kernel state, and the data from the disk is read into the kernel buffer by means of DMA (Direct memory access). Instead, the DMA processor transfers the hard disk data directly to memory via the bus.
The system changes from kernel state to user state, and when the data to be read by the program has been completely stored in the kernel read buffer, the program writes the data from the kernel read buffer to the user buffer, a process that requires the CPU to participate in reading and writing the data.
When the program uses the write() system call, the system switches from the user state to the kernel state and writes data from the user buffer to the network buffer (Socket Buffer), a process that requires the CPU to participate in reading and writing data.
The system switches from kernel state to user state, and the data in the network buffer is transferred to the driver (storage buffer) of the NIC (protocol engine) by DMA.
As you can see, the common copy process goes through four kernel and user state switches (context switches) and two CPU read/write processes from memory, which is relatively more system resource intensive.&lt;/p&gt;
&lt;h3 id=&#34;memory-mapping-method-io&#34;&gt;Memory mapping method I/O&lt;/h3&gt;
&lt;div align=center&gt; &lt;img alt=&#34;System call flow chart&#34; src=&#34;https://cdn.jsdelivr.net/gh/javaisland/images/2022/03/26/0a5f9878b34b4f3489c4cf3307ec976f.jpg&#34;/&gt;&lt;/div&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;tmp_buf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mmap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tmp_buf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;This is the system call method used. The I/O principle of this method is to map the memory address of the user buffer to the memory address of the kernel buffer, which means that the system can read and manipulate the kernel data directly in the user state.&lt;/p&gt;
&lt;p&gt;The mmap() system call first reads the disk data into the kernel buffer using DMA, and then makes the memory address of the user buffer and the kernel read buffer the same memory address through memory mapping, which means there is no need for the CPU to copy the data from the kernel read buffer to the user buffer.
When the write() system call is used, the CPU writes the data from the kernel buffer (equivalent to the user buffer) directly to the network send buffer (socket buffer), and then passes the data to the NIC driver for sending by DMA.
You can see that this way of memory mapping reduces the number of CPU reads and writes, but the switch from user state to kernel state (context switch) is still four times, and this way allows the application to read and write the data accordingly.&lt;/p&gt;
&lt;h3 id=&#34;kernel-space-internal-transfer-io&#34;&gt;Kernel space internal transfer I/O&lt;/h3&gt;
&lt;div align=center&gt; &lt;img alt=&#34;System call flow chart&#34; src=&#34;https://cdn.jsdelivr.net/gh/javaisland/images/2022/03/26/f26ec3dbaf5f430fb31634e5aa992edf.jpg&#34;/&gt;&lt;/div&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sendfile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The sendfile() system call allows for direct I/O transfers from within kernel space.&lt;/p&gt;
&lt;p&gt;The sendfile() system call also causes a switch from the user state to the kernel state. Unlike the memory mapping method, the user space cannot see or modify the data content at this point, which means that this is a full data transfer process.
Reading from disk to memory is DMA, reading from the kernel read buffer to the network send buffer still requires the CPU to participate in the copy, and reading from the network send buffer to the buffer in the NIC is still DMA.
There is still one CPU data copy and two user-state and kernel-state switching operations. This is a great improvement compared to the memory mapping approach, but the problem is that the program cannot modify the data, but simply performs a data transfer process.&lt;/p&gt;
&lt;h3 id=&#34;upgraded-version---kernel-space-internal-transfer-io&#34;&gt;Upgraded version - kernel space internal transfer I/O&lt;/h3&gt;
&lt;div align=center&gt; &lt;img alt=&#34;System call flow chart&#34; src=&#34;https://cdn.jsdelivr.net/gh/javaisland/images/2022/03/26/7fa0158788c24857b6a6207e09539d24.jpg&#34;/&gt; &lt;/div&gt;
&lt;p&gt;Still the system call sendfile().&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sendfile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In Linux kernel 2.4 and later versions, the socket buffer descriptor has been adjusted to support the DMA self-collection function, which is still the same for the user, but the internal operation has changed.&lt;/p&gt;
&lt;p&gt;As you can see, this is truly zero-copy, because the CPU is no longer involved in the data copying process, but of course such a process requires hardware support to achieve.&lt;/p&gt;
&lt;p&gt;With the help of the hardware, we can do it. In fact, we just need to pass the buffer descriptor to the socket buffer and then pass the data length, so that the DMA controller can directly pack the data from the page cache and send it to the network.&lt;/p&gt;
&lt;p&gt;After the system call sendfile() is initiated, the disk data is read into the kernel buffer by DMA, and the data in the kernel buffer is aggregated into the network buffer by DMA and then sent to the NIC together.
As you can see, in this mode, there is no CPU data copy, so there is really zero copy.&lt;/p&gt;
&lt;h3 id=&#34;subsequent-optimization-splice-system-call&#34;&gt;Subsequent optimization-splice() system call&lt;/h3&gt;
&lt;p&gt;The splice() system call is very similar to sendfile() in that the user application must have two open file descriptors, one for the input device and one for the output device. Unlike sendfile(), splice() allows any two files to be connected to each other, not just files to a socket for data transfer. The sendfile() system call has always been used for the special case of sending data from a file descriptor to a socket, whereas splice has always been a mechanism that is not limited to the function of sendfile(). In other words, sendfile() is just a subset of splice(). In Linux 2.6.23, the implementation of sendfile() is no longer available, but the API and the corresponding functions still exist, except that the API and the corresponding functions are implemented using the splice() mechanism.&lt;/p&gt;
&lt;p&gt;In general, splice() is a method that replaces the sendfile() system call in Linux 2.6.23 kernel version. It supports not only direct file-to-socket transfer, but also direct file-to-file I/O transfer, but the underlying transfer process is no different from that of sendfile().&lt;/p&gt;
&lt;h2 id=&#34;zero-copy-in-javanio&#34;&gt;Zero-copy in JavaNIO&lt;/h2&gt;
&lt;h3 id=&#34;memory-mapped-io-in-nio&#34;&gt;Memory-mapped I/O in NIO&lt;/h3&gt;
&lt;p&gt;The first thing to explain is that the Channel (channel) in JavaNIO is equivalent to the kernel buffer in the operating system, which may be a read buffer or a network buffer, and the Buffer is equivalent to the user buffer in the operating system.&lt;/p&gt;
&lt;p&gt;Correction: The operating system&amp;rsquo;s read and write buffers have no relationship with JavaNIO, the operating system&amp;rsquo;s read and write buffers (in Linux is the PageCache) is the kernel and IO devices directly interact with the driver memory area, the programmer usually can not touch&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look at a piece of code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;File&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;File&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;test.zip&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;RandomAccessFile&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RandomAccessFile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;rw&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;FileChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileChannel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;MappedByteBuffer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FileChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;MapMode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;READ_ONLY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The FileChannel.map() method in IO actually uses the memory mapping method in the operating system
Memory address mapping is actually a mapping of memory addresses and disk files by the OS, and reading and writing to this memory is equivalent to reading and writing to the disk files directly, but the actual reading still goes through the OS to read into the memory PageCache, and the writing process also requires the OS to automatically replace the dirty pages to the disk.&lt;/p&gt;
&lt;p&gt;This approach is suitable for reading large files and also for making changes to the file content, but if the file is subsequently sent via SocketChannel, the CPU is still required to make a copy of the data&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;processData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// After data processing is complete, open a SocketChannel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InetSocketAddress&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1234&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// This still requires the CPU to copy the contents of the kernel buffer to the network buffer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;zero-copy-in-nio&#34;&gt;Zero copy in NIO&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;File&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;File&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;test.zip&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;RandomAccessFile&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RandomAccessFile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;rw&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;FileChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileChannel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InetSocketAddress&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1234&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// TransferTo() is used directly for data transfer between channels
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fileChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;transferTo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div align=center&gt; &lt;img alt=&#34;System call flow chart&#34; src=&#34;https://cdn.jsdelivr.net/gh/javaisland/images/2022/03/26/c5e5d46e8cc4473dbb0fdffeb38c39f3.png&#34;/&gt; &lt;/div&gt;
&lt;p&gt;his approach is the zero copy in NIO, let&amp;rsquo;s analyze the principle:&lt;/p&gt;
&lt;p&gt;Buffer in NIO are in user space, including DirectBuffer, which is also a piece of memory malloc out of C language.&lt;/p&gt;
&lt;p&gt;The way transferTo() is implemented is through the system call sendfile() (of course, this is a system call in Linux, the system call in Windows is different), and according to what we wrote above, this process is much more efficient than reading and writing from the kernel buffer to the user buffer.
Similarly transferFrom() is also implemented in this way.&lt;/p&gt;
&lt;p&gt;At the same time we came to a conclusion, the efficiency of IO in Java is far worse than C and C++, because the existence of the JVM leads to Java&amp;rsquo;s IO will always be more than other languages to exchange a layer of memory, but Java is still promising in middleware, for example, message queues, kafka is written in Java, throughput and stability have reached a satisfactory effect.&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
